<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Routing in Histograms (p5.js)</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="script.js" defer></script>
</head>
<body>

  <div class="content-wrapper">
    <header class="intro-header">
      <h1>Routing in Histograms</h1>
      <p>
       This page provides the preliminary concepts required to understand the shortest-path routing scheme presented in the paper "Routing in Histograms." The algorithm allows a data packet to navigate between any two vertices in a histogram efficiently, using minimal stored information.
      </p>
      </header>

  <h2>1. The Environment: Histograms and Visibility</h2>

<h4>Histogram Polygon (P)</h4>
<p>
  In this context, a histogram is a specific type of polygon with two key properties. First, it is <strong>orthogonal</strong>, meaning all its corners are 90° angles. Second, it is <strong>x-monotone</strong>, which means that its lower boundary never "doubles back" on itself horizontally as you trace it from left to right. The top of the histogram is a single, uninterrupted horizontal edge.
</p>

<h4>R-Visibility and the Graph G(P)</h4>
<p>
  The connections between vertices are not standard straight lines. Instead, the algorithm uses <strong>rectilinear visibility (r-visibility)</strong>. Two vertices `v` and `w` are considered "co-visible" if the axis-aligned rectangle between them lies entirely within the histogram. The network of all such connections forms the <strong>r-visibility graph G(P)</strong>, which is the "map" our algorithm navigates.
</p>

<h2>2. Vertex Classification</h2>
<p>
  Every vertex in the histogram is classified based on its local geometry, which is crucial for routing decisions. Each vertex has two properties: its orientation (left/right) and its angle (convex/reflex).
</p>
<ul>
  <li><strong>Left vs. Right Vertex:</strong> Every vertex is an endpoint of exactly one horizontal edge. If it is the <em>left</em> endpoint, it's a <strong>left vertex</strong>. Otherwise, it's a <strong>right vertex</strong>.</li>
  <li><strong>Convex vs. Reflex Vertex:</strong> If the interior angle at a vertex is 90° (π/2), it is <strong>convex</strong>. If the interior angle is 270° (3π/2), it is <strong>reflex</strong>.</li>
</ul>
<p>This gives four combined types: <strong>l-convex, r-convex, l-reflex,</strong> and <strong>r-reflex</strong>.</p>

<h2>3. The Routing Scheme Components</h2>
<p>The routing scheme equips each vertex with minimal information to make smart, local decisions.</p>
<ul>
  <li><strong>Label `lab(v)`:</strong> This is the unique address of a vertex `v`. It contains the vertex's index (`vid`) and, for reflex vertices, the index of a special landmark called its "breakpoint" (`br(v)`). The label format is `(vid, br(v)id)`.</li>
  <li><strong>Routing Table `p(v)`:</strong> A tiny piece of stored data. In this paper's scheme, it is just a single bit indicating whether the left visible neighbor `l(v)` is higher or lower than the right visible neighbor `r(v)`.</li>
  <li><strong>Stretch Factor:</strong> A measure of path quality. It's the ratio of the routing path's length to the true shortest path's length. This scheme achieves a stretch factor of 1, meaning it always finds the absolute shortest path.</li>
</ul>

<h2>4. Navigational Landmarks</h2>
<p>The algorithm doesn't have a global map. Instead, it uses a set of local landmarks visible from the current vertex `s` to determine the next hop towards a target `t`.</p>
<ul>
  <li><strong>Corresponding Vertex `cv(v)`:</strong> The other vertex that shares the same horizontal edge as `v`.</li>
  <li><strong>Left/Right Bounding Vertices `l(v)` and `r(v)`:</strong> From a vertex `v`, `l(v)` is the leftmost vertex it can see, and `r(v)` is the rightmost.</li>
  <li><strong>Interval `I(s)`:</strong> The set of all vertices located horizontally between `l(s)` and `r(s)`. A key first step in routing is to check if the target `t` is within the current interval `I(s)`.</li>
  <li><strong>Near/Far Dominators `nd(s, t)` and `fd(s, t)`:</strong> These are crucial when the target `t` is inside the current interval `I(s)` but not directly visible. The <strong>near dominator `nd(s, t)`</strong> is the rightmost neighbor of `s` that is to the left of `t`. The <strong>far dominator `fd(s, t)`</strong> is the leftmost neighbor of `s` that is to the right of `t`. These two vertices effectively "gate" the region containing the target.</li>
  <li><strong>Breakpoint `br(v)`:</strong> This applies to reflex vertices and is a key part of the vertex label. For an r-reflex vertex `v`, its breakpoint `br(v)` is the highest visible vertex to its right that is below it. This landmark essentially acts as an "escape route" from the pocket created by the reflex vertex.</li>
</ul>
</header>
    </header>


  </div>

</body>
</html>